#include <iostream>
#include <vector>
#include <cstring>
#include <cmath>
#include <vector>
using namespace std;
typedef long long LL;
typedef pair<int,int> PLL;
const int N=1e6+5;
const int mod=1e9+7;
/*********************************************************************************************
								最大公约数gcd、最小公倍数lcm 
*********************************************************************************************/
LL gcd(LL a,LL b){
	return b ? gcd(b,a%b) : a; 
}
LL lcm(LL a,LL b){
	return a/gcd(a,b)*b;
}


/*********************************************************************************************
							快速乘（很少用,当a*a>long long时采用）
*********************************************************************************************/
LL quick_mul(LL a,LL b,LL p) {                //a*b%p
	LL ans=0;
	a%=p;
	b%=p;
	while(b) {
		if (b&1) ans=(ans+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return ans;
}

/*********************************************************************************************
										快速幂
						欧拉取模进化公式：	(a^b)%p=( a%p )^( b%phi(p) )%p;
						超欧拉取模进化公式：(a^b)%p=( a%p )^( phi(p)+b%phi(p) )%p
*********************************************************************************************/
LL quick_pow(LL a,LL b,LL p) {                       //a的b次方 , %p
	LL ans=1;
	a%=p;
	while(b) {
		if (b&1) ans=ans*a%p;
		a=a*a%p;
		b>>=1;
	}
	return ans;
}

/*********************************************************************************************
										扩展欧几里得
*********************************************************************************************/
void ex_gcd(LL a,LL b,LL &x,LL &y,LL &d) {
	if (!b) {
		d=a;
		x=1;
		y=0;
	} else {
		ex_gcd(b,a%b,y,x,d);
		y-=x*(a/b);
	}
}
/*********************************************************************************************
										单个逆元
									对于(a/b)%p=a*inv(b)
				1.（b与p互质） 欧拉定理 b关于p的逆元 					 inv(b)=b^( phi(p)-1 )
				2.（b与p互质并且p为素数）费马小定理 b关于p的逆元		 inv(b)=b^(p-2)
				3. (a与p不互质) (a/b)%p=
*********************************************************************************************/
LL get_inv(LL a,LL p) {		//	a关于p的逆元
	//如果p是素数，直接返回  a的p-2次方%p		quick_pow(a,p-2,p);
	LL d,x,y;
	ex_gcd(a,p,x,y,d);
	return (d==1) ? (x%p+p)%p : -1;
}

/*********************************************************************************************
									关于p乘法逆元打表
*********************************************************************************************/
LL inv[N];
void build_inv(int p) {						//O(n)关于p线性打逆元表
	inv[1]=1;
	for (int i=2; i<N; i++)
		inv[i]=(p-p/i)*inv[p%i]%p;
}


/*********************************************************************************************
										中国剩余定理
							n个方程：x=a[i](mod m[i]) (0<=i<n)	m之间 两两互质

									W= m1*m2*m3  *mn
									Mi=W/mi;
									ti=inv(Mi,mi);
									x=sigma(ai * ti * Mi );
*********************************************************************************************/

LL china(int n, LL *a, LL *m) {
	LL M = 1, ret = 0;
	for(int i = 0; i < n; i ++) M *= m[i];
	for(int i = 0; i < n; i ++) {
		LL w = M / m[i];
		ret = (ret + w * get_inv(w, m[i]) * a[i]) % M;
	}
	return (ret + M) % M;
}
/*********************************************************************************************
										中国剩余定理
				n个方程：A[i]x=B[i](mod M[i]) (0<=i<n)	m之间不互质
*********************************************************************************************/
PLL linear(LL A[], LL B[], LL M[], int n) {//求解A[i]x = B[i] (mod M[i]),总共n个线性方程组
	LL x = 0, m = 1;
	for(int i = 0; i < n; i ++) {
		LL a = A[i] * m, b = B[i] - A[i]*x, d = gcd(M[i], a);
		if(b % d != 0)  return PLL(0, -1);//答案不存在，返回-1
		LL t = b/d * inv(a/d, M[i]/d)%(M[i]/d);
		x = x + m*t;
		m *= M[i]/d;
	}
	x = (x % m + m ) % m;
	return PLL(x, m);//返回的x就是答案，m是最后的lcm值
}


/*********************************************************************************************
										主程序
*********************************************************************************************/

void solve() {
	LL a,p;
	cin>>a>>p;
	cout<<get_inv(a,p)<<endl;
}

int main() {
//文件读入
//	freopen("datain.txt","r",stdin);

//取消缓冲，加速读入
	ios::sync_with_stdio(false);
	cin.tie(0);

//正文
	int T;
	cin>>T;
	while(T--) {
		solve();
	}
	return 0;
}
